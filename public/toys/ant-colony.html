<!DOCTYPE html>
<html>
<head>
    <meta name="description" content="An ant colony simulation demonstrating swarm intelligence and pheromone-based pathfinding">
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #2d2d2d;
            color: #fff;
            font-family: system-ui, -apple-system, sans-serif;
            padding: 20px;
        }
        canvas {
            background: #1a1a1a;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        button {
            background: #4a4a4a;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #5a5a5a;
        }
        .stats {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h2>Ant Colony Simulation</h2>
    <canvas id="antCanvas"></canvas>
    <div class="controls">
        <button onclick="toggleSimulation()">Play/Pause</button>
        <button onclick="addFood()">Add Food</button>
        <button onclick="addObstacle()">Add Obstacle</button>
    </div>
    <div class="stats" id="stats"></div>

    <script>
        const canvas = document.getElementById('antCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        let isRunning = true;
        let mouseX = 0;
        let mouseY = 0;
        let isPlacingFood = false;
        let isPlacingObstacle = false;
        let draggedAnt = null;
        let isDragging = false;

        // Colony configuration
        const COLONY_SIZE = 50;
        const PHEROMONE_STRENGTH = 0.3;
        const PHEROMONE_DECAY = 0.995;
        const ANT_SPEED = 2;
        const INITIAL_FOOD_SOURCES = 5;
        const INITIAL_OBSTACLES = 8;
        const MIN_FOOD_SOURCES = 3;
        const FOOD_SOURCE_SIZE = 30;
        const FOOD_REPLENISH_CHANCE = 0.01; // Chance per frame to add new food when below minimum
        const SENSOR_ANGLE = Math.PI / 4;
        const SENSOR_DISTANCE = 20;

        class Vec2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                return new Vec2(this.x + v.x, this.y + v.y);
            }

            sub(v) {
                return new Vec2(this.x - v.x, this.y - v.y);
            }

            mul(s) {
                return new Vec2(this.x * s, this.y * s);
            }

            normalize() {
                const len = Math.sqrt(this.x * this.x + this.y * this.y);
                return new Vec2(this.x / len, this.y / len);
            }

            rotate(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return new Vec2(
                    this.x * cos - this.y * sin,
                    this.x * sin + this.y * cos
                );
            }
        }

        class Ant {
            constructor(x, y) {
                this.pos = new Vec2(x, y);
                this.dir = new Vec2(Math.random() - 0.5, Math.random() - 0.5).normalize();
                this.hasFood = false;
                this.energy = 100;
                this.radius = 4; // Added for drag detection

                this.wandering = true;
                this.lastFoodSourceSize = 0;
                this.distanceWalked = 0;
            }

            containsPoint(x, y) {
                const dx = this.pos.x - x;
                const dy = this.pos.y - y;
                return dx * dx + dy * dy < this.radius * this.radius;
            }

            update(foodPheromones, homePheromones, obstacles, foods) {
                // Skip normal movement if being dragged
                if (this === draggedAnt) {
                    return;
                }

                // Sense surroundings
                const pheromones = (this.hasFood || this.energy <= 0) ? homePheromones : foodPheromones
                const leftSensor = this.sense(-SENSOR_ANGLE, pheromones);
                const centerSensor = this.sense(0, pheromones);
                const rightSensor = this.sense(SENSOR_ANGLE, pheromones);

                // Steering behavior
                if (centerSensor > leftSensor && centerSensor > rightSensor) {
                    // Continue straight
                } else if (leftSensor > rightSensor) {
                    this.dir = this.dir.rotate(-0.1);
                    this.wandering = false;
                } else if (rightSensor > leftSensor) {
                    this.dir = this.dir.rotate(0.1);
                    this.wandering = false;
                } else {
                    // Random walk
                    this.dir = this.dir.rotate((Math.random() - 0.5) * 0.3);
                    this.wandering = true;
                }

                // Move
                const newPos = this.pos.add(this.dir.mul(this.energy <= 0 ? ANT_SPEED * 0.5 : ANT_SPEED));

                // Bounce off walls
                if (newPos.x < 0 || newPos.x > canvas.width) {
                    this.dir.x *= -1;
                }
                if (newPos.y < 0 || newPos.y > canvas.height) {
                    this.dir.y *= -1;
                }

                // Check for obstacles
                let hitObstacle = false;
                for (const obstacle of obstacles) {
                    const dx = newPos.x - obstacle.x;
                    const dy = newPos.y - obstacle.y;
                    if (dx * dx + dy * dy < obstacle.radius * obstacle.radius) {
                        hitObstacle = true;
                        this.dir = this.dir.rotate(Math.random() - 0.5);
                        break;
                    }
                }

                if (!hitObstacle) {
                    this.pos = newPos;
                    this.distanceWalked++;
                }

                // Handle food
                if (!this.hasFood) {
                    for (const food of foods) {
                        const dx = this.pos.x - food.x;
                        const dy = this.pos.y - food.y;
                        if (dx * dx + dy * dy < food.amount * food.amount) {
                            this.hasFood = true;
                            food.amount -= 1;
                            this.lastFoodSourceSize = food.amount;
                            this.distanceWalked = 0;
                            this.dir = this.dir.rotate(Math.PI);
                            this.energy = 100;
                            break;
                        }
                    }
                }
                else {
                    // Check if back at nest
                    const dx = this.pos.x - canvas.width / 2;
                    const dy = this.pos.y - canvas.height / 2;
                    if (dx * dx + dy * dy < 400) {
                        this.hasFood = false;
                        this.distanceWalked = 0;
                        this.dir = this.dir.rotate(Math.PI);
                        colony.storedFood += 1;
                        colony.totalCollected += 1;
                    }
                }

                // Update energy
                this.energy -= 0.1;
                if (this.energy <= 0) {
                    this.returnToNest();
                }

                this.depositPheromones(foodPheromones, homePheromones);
            }

            returnToNest() {
                // Just drop any food and we'll start following home pheromones
                this.hasFood = false;

                // Check if already at nest
                const dx = this.pos.x - canvas.width / 2;
                const dy = this.pos.y - canvas.height / 2;
                if (dx * dx + dy * dy < 400) {
                    if (colony.storedFood > 0) {
                        colony.storedFood -= 1;
                        this.energy = 100;
                        this.distanceWalked = 0;
                    }
                    else {
                        // If no food is stored, ant remains tired
                        // this.energy = Math.min(30, this.energy + 0.1); // Slow passive recovery
                    }
                }
            }

            sense(angle, pheromoneMap) {
                const sensorDir = this.dir.rotate(angle);
                const sensorPos = this.pos.add(sensorDir.mul(SENSOR_DISTANCE));

                let sum = 0;
                const radius = 5;

                // Pheromone sensing
                const pheromoneThreshold = 0.01;
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const x = Math.floor(sensorPos.x + dx);
                        const y = Math.floor(sensorPos.y + dy);

                        if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                            sum +=  pheromoneMap[y * canvas.width + x] || 0;
                        }
                    }
                }

                // Direct sensing of food or nest
                const directSenseRadius = 50;
                if (!this.hasFood || pheromoneMap === foodPheromones) {
                    // Check for nearby food
                    for (const food of foods) {
                        if (food.amount <= 1) continue;
                        const dx = sensorPos.x - food.x;
                        const dy = sensorPos.y - food.y;
                        const distSquared = dx * dx + dy * dy;
                        if (distSquared < directSenseRadius * directSenseRadius) {
                            // Add strong signal that falls off with distance
                            sum += 5.0 * (10000 / (distSquared + 1));
                        }
                    }
                }
                if (pheromoneMap === homePheromones || this.distanceWalked > this.distanceThreshold) {
                    // Check for nest
                    const dx = sensorPos.x - canvas.width / 2;
                    const dy = sensorPos.y - canvas.height / 2;
                    const distSquared = dx * dx + dy * dy;
                    if (distSquared < directSenseRadius * directSenseRadius) {
                        // Add strong signal that falls off with distance
                        sum += 5.0 * (10000 / (distSquared + 1));
                        // If the ant can sense the nest, it can start leaving home pheromones again.
                        this.distanceWalked = Math.min(this.distanceWalked, Math.sqrt(distSquared));
                    }
                }

                return sum;
            }

            distanceThreshold = 300;

            depositPheromones(foodPheromones, homePheromones) {
                if (this.energy <= 0) return; // Tired ants don't leave pheromones

                const distanceThreshold = 300;

                const idx = Math.floor(this.pos.y) * canvas.width + Math.floor(this.pos.x);
                if (this.hasFood) {
                    if (!this.wandering) {
                        foodPheromones[idx] = PHEROMONE_STRENGTH *
                          (this.lastFoodSourceSize / FOOD_SOURCE_SIZE);/* *
                          Math.max(0, (this.distanceThreshold - this.distanceWalked) / this.distanceThreshold);*/
                    }
                }
                else {
                    homePheromones[idx] = PHEROMONE_STRENGTH *
                      Math.max(0, (this.distanceThreshold - this.distanceWalked) / this.distanceThreshold);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(Math.atan2(this.dir.y, this.dir.x));

                // Ant body
                ctx.fillStyle = this.hasFood ? '#ffd700' : '#8b4513';
                ctx.beginPath();
                ctx.ellipse(0, 0, 4, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Antennae
                ctx.strokeStyle = '#8b4513';
                ctx.beginPath();
                ctx.moveTo(2, -2);
                ctx.lineTo(6, -4);
                ctx.moveTo(2, 2);
                ctx.lineTo(6, 4);
                ctx.stroke();

                ctx.restore();
            }
        }

        const colony = {
            ants: Array(COLONY_SIZE).fill().map(() =>
                new Ant(canvas.width / 2, canvas.height / 2)
            ),
            storedFood: 0,
            totalCollected: 0
        };

        let foodPheromones = new Float32Array(canvas.width * canvas.height);
        let homePheromones = new Float32Array(canvas.width * canvas.height);
        const obstacles = [];
        const foods = [];

        function updatePheromones() {
            // Decay existing pheromones
            for (let i = 0; i < foodPheromones.length; i++) {
                foodPheromones[i] *= PHEROMONE_DECAY;
                homePheromones[i] *= PHEROMONE_DECAY;

                const pheromoneThreshold = 0.01;
                if (foodPheromones[i] < pheromoneThreshold) foodPheromones[i] = 0;
                if (homePheromones[i] < pheromoneThreshold) homePheromones[i] = 0;
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw pheromones
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < foodPheromones.length; i++) {
                const idx = i * 4;
                data[idx] = foodPheromones[i] * 2 * 255; // Red for food pheromones
                data[idx + 1] = homePheromones[i] * 2 * 255; // Green for home pheromones
                data[idx + 2] = 0;
                data[idx + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw nest
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 20, 0, Math.PI * 2);
            ctx.fill();

            // Draw obstacles
            obstacles.forEach(obstacle => {
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw food placement or obstacle preview
            if (isPlacingFood) {
                ctx.fillStyle = 'rgba(144, 238, 144, 0.5)';
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, FOOD_SOURCE_SIZE, 0, Math.PI * 2);
                ctx.fill();
            } else if (isPlacingObstacle) {
                ctx.fillStyle = 'rgba(68, 68, 68, 0.5)';
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 20, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw food sources
            foods.forEach(food => {
                if (food.amount > 0) {
                    ctx.fillStyle = '#90EE90';
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, food.amount, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw ants
            colony.ants.forEach(ant => ant.draw());

            // Update stats
            document.getElementById('stats').innerHTML = `
                Total Food Collected: ${colony.totalCollected}
                Food Stored in Nest: ${colony.storedFood}
                Ants: ${colony.ants.length}
                Food Sources: ${foods.filter(f => f.amount > 0).length}
                Obstacles: ${obstacles.length}
            `;
        }

        function update() {
            if (!isRunning) return;

            updatePheromones();

            colony.ants.forEach(ant => {
                ant.update(foodPheromones, homePheromones, obstacles, foods);
            });

            // Clean up depleted food sources and possibly add new ones
            for (let i = foods.length - 1; i >= 0; i--) {
                if (foods[i].amount <= 1) {
                    foods.splice(i, 1);
                }
            }

            // Check if we need to replenish food sources
            if (foods.length < MIN_FOOD_SOURCES && Math.random() < FOOD_REPLENISH_CHANCE) {
                addRandomFoodSource();
            }

            // Check if a new ant will be born
            const newAntCost = 50;
            if (colony.storedFood >= colony.ants.length + newAntCost) {
                colony.storedFood -= newAntCost;
                colony.ants.push(new Ant(canvas.width / 2, canvas.height / 2));
            }
        }

        function initializeEnvironment() {
            // Add initial food sources
            for (let i = 0; i < INITIAL_FOOD_SOURCES; i++) {
                addRandomFoodSource();
            }

            // Add initial obstacles
            for (let i = 0; i < INITIAL_OBSTACLES; i++) {
                addRandomObstacle();
            }
        }

        function addRandomFoodSource() {
            const margin = 50; // Keep away from edges
            const nestMargin = 100; // Keep away from nest
            let x, y;

            do {
                x = margin + Math.random() * (canvas.width - 2 * margin);
                y = margin + Math.random() * (canvas.height - 2 * margin);
            } while (isNearNest(x, y, nestMargin) || isNearOtherFood(x, y) || isNearObstacle(x, y));

            foods.push({ x, y, amount: FOOD_SOURCE_SIZE });
        }

        function addRandomObstacle() {
            const margin = 50;
            const nestMargin = 100;
            let x, y;

            do {
                x = margin + Math.random() * (canvas.width - 2 * margin);
                y = margin + Math.random() * (canvas.height - 2 * margin);
            } while (isNearNest(x, y, nestMargin) || isNearOtherObstacle(x, y) || isNearFood(x, y));

            obstacles.push({ x, y, radius: 20 });
        }

        function isNearNest(x, y, margin) {
            const dx = x - canvas.width / 2;
            const dy = y - canvas.height / 2;
            return dx * dx + dy * dy < margin * margin;
        }

        function isNearOtherFood(x, y) {
            return foods.some(food => {
                const dx = x - food.x;
                const dy = y - food.y;
                return dx * dx + dy * dy < 50 * 50;
            });
        }

        function isNearOtherObstacle(x, y) {
            return obstacles.some(obstacle => {
                const dx = x - obstacle.x;
                const dy = y - obstacle.y;
                return dx * dx + dy * dy < 50 * 50;
            });
        }

        function isNearFood(x, y) {
            return foods.some(food => {
                const dx = x - food.x;
                const dy = y - food.y;
                return dx * dx + dy * dy < 50 * 50;
            });
        }

        function isNearObstacle(x, y) {
            return obstacles.some(obstacle => {
                const dx = x - obstacle.x;
                const dy = y - obstacle.y;
                return dx * dx + dy * dy < 50 * 50;
            });
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Initialize the environment before starting
        initializeEnvironment();

        function toggleSimulation() {
            isRunning = !isRunning;
        }

        function addFood() {
            isPlacingFood = true;
            isPlacingObstacle = false;
        }

        function addObstacle() {
            isPlacingObstacle = true;
            isPlacingFood = false;
        }


        function getXY (e) {
            const rect = canvas.getBoundingClientRect();
            const { clientX, clientY } = e.touches?.[0] ?? e;

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            return [x, y];
        }

        canvas.addEventListener('click', (e) => {
            const [x, y] = getXY(e);

            if (isPlacingFood) {
                foods.push({ x, y, amount: 30 });
                isPlacingFood = false;
            } else if (isPlacingObstacle) {
                obstacles.push({ x, y, radius: 20 });
                isPlacingObstacle = false;
            }
        });

        const handleDragStart = (e) => {
            if (isPlacingFood || isPlacingObstacle) return;

            const [x, y] = getXY(e);

            // Check if we clicked on an ant
            for (const ant of colony.ants) {
                if (ant.containsPoint(x, y)) {
                    e.preventDefault();
                    draggedAnt = ant;
                    isDragging = true;
                    // Update direction to match drag
                    const dx = x - draggedAnt.pos.x;
                    const dy = y - draggedAnt.pos.y;
                    if (dx !== 0 || dy !== 0) {
                        draggedAnt.dir = new Vec2(dx, dy).normalize();
                        draggedAnt.pos.x = x;
                        draggedAnt.pos.y = y;
                    }
                    return;
                }
            }
        };

        canvas.addEventListener('mousedown', handleDragStart);
        canvas.addEventListener('touchstart', handleDragStart);

        const handleDrag = (e) => {
            const [x, y] = getXY(e);

            if (isDragging && draggedAnt) {
                // Update ant direction while dragging
                const dx = x - draggedAnt.pos.x;
                const dy = y - draggedAnt.pos.y;
                if (dx !== 0 || dy !== 0) {
                    draggedAnt.dir = new Vec2(dx, dy).normalize();
                    draggedAnt.pos.x = x;
                    draggedAnt.pos.y = y;
                }
            }
            else {
                [mouseX, mouseY] = [x, y];
            }
        };

        canvas.addEventListener('mousemove', handleDrag);
        canvas.addEventListener('touchmove', handleDrag);

        const handleDragEnd = () => {
            isDragging = false;
            draggedAnt = null;
        };

        canvas.addEventListener('mouseup', handleDragEnd);
        canvas.addEventListener('touchend', handleDragEnd);

        gameLoop();
    </script>
</body>
</html>